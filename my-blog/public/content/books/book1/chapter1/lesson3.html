<div class="lesson-container">
  <p class="lesson-intro">Đây là nội dung chi tiết cho <strong>Bài 3</strong>. Đây là một bài học nền tảng cực kỳ quan trọng.<br>
  Trong C#, bạn thường chỉ quen tay gõ int, long, double. Nhưng trong lập trình Blockchain và Hệ thống, việc chọn sai kiểu dữ liệu (ví dụ: dùng int cho số dư token) có thể dẫn đến lỗ hổng bảo mật tỉ đô (như lỗi Integer Overflow). Rust ép bạn phải kỷ luật ngay từ bước này.</p>
  <h1 class="lesson-part">PHẦN 1: TƯ DUY CỐT LÕI & "CAI NGHIỆN" GC</h1>
  <h2 class="lesson-chapter">CHƯƠNG 1: HELLO RUST & TOOLING</h2>
  <h3 class="lesson-title">BÀI 3: PRIMITIVE TYPES & CONTROL FLOW <span class="lesson-subtitle">(KIỂU NGUYÊN THỦY & ĐIỀU KHIỂN LUỒNG)</span></h3>
  <p class="lesson-text">Chào bạn, hôm nay chúng ta sẽ đi vào "từng viên gạch" cấu tạo nên chương trình Rust.<br>
  Nếu C# cố gắng làm cho mọi thứ trở nên "tiện lợi" (ví dụ: int mặc định là 32-bit, tự động ép kiểu ngầm định), thì Rust ưu tiên sự <strong>Rõ ràng (Explicit)</strong>. Trong Rust, bạn phải biết chính xác mình đang dùng bao nhiêu bit bộ nhớ. Điều này cực kỳ quan trọng để tối ưu gas fee trong Smart Contract sau này.</p>
  <h4 class="lesson-section">1. Scalar Types: Những con số biết nói</h4>
  <p class="lesson-text">Trong C#, hệ thống kiểu số khá đơn giản. Trong Rust, nó được phân loại cực kỳ chi tiết dựa trên số bit.</p>
  <table class="lesson-table">
    <thead>
      <tr>
        <th>Loại C#</th>
        <th>Rust</th>
        <th>Ý nghĩa trong Rust</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>sbyte, short, int, long</td><td>i8, i16, i32, i64, i128</td><td>i là "integer". Số đi kèm là số bit. i128 cực hữu ích cho Cryptography.</td></tr>
      <tr><td>byte, ushort, uint, ulong</td><td>u8, u16, u32, u64, u128</td><td>u là "unsigned" (không âm). Blockchain dùng cái này 99% (vì số dư không thể âm).</td></tr>
      <tr><td>nint, nuint (C# 9.0+)</td><td>isize, usize</td><td>Phụ thuộc vào máy (64-bit hay 32-bit). Dùng để đánh index cho mảng.</td></tr>
      <tr><td>float, double</td><td>f32, f64</td><td>f64 là mặc định (giống double).</td></tr>
      <tr><td>bool</td><td>bool</td><td>true / false.</td></tr>
      <tr><td>char (2 bytes - UTF16)</td><td>char (4 bytes - Unicode)</td><td>char của Rust chứa được cả emoji.</td></tr>
    </tbody>
  </table>
  <p class="lesson-warning">Cảnh báo Blockchain:<br>
  Trong Ethereum (Solidity), kiểu dữ liệu chuẩn là uint256. Rust hỗ trợ u128 là native lớn nhất. Để xử lý số lớn như ví Ethereum, sau này ta sẽ dùng thư viện (như BigInt), nhưng tư duy về u64 (cho số lượng coin nhỏ) là nền tảng.</p>
  <p class="lesson-text">Cách viết số (Literals):</p>
  <pre class="lesson-code"><code class="lesson-code-rust">let price: u64 = 1_000_000_000; // 1 tỷ
let hex_val = 0xff;</code></pre>
  <h4 class="lesson-section">2. Toán tử & Overflow: Bài học đau thương</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let a: u8 = 255; 
    // u8 chạy từ 0 đến 255.   
    // Nếu chạy 'cargo run' (debug): Chương trình CRASH ngay tại đây.
    // Nếu chạy 'cargo run --release': Nó sẽ wrap về 0 (giống C#).
    let b = a + 1;   
    println!("{}", b);
}</code></pre>

  <h4 class="lesson-section">3. Compound Types: Tuples & Arrays</h4>
  <p class="lesson-text"><strong>Tuples (Bộ giá trị):</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    // Một tuple chứa: (ID, Amount, Currency)
    let transaction: (i32, f64, &str) = (500, 6.5, "USD");

    // Destructuring (Phân rã) - Cực kỳ hay dùng
    let (id, amount, currency) = transaction;
    
    // Hoặc truy cập bằng dấu chấm
    println!("Giao dịch {} chuyển {} {}", transaction.0, transaction.1, transaction.2);
}</code></pre>

  <p class="lesson-text"><strong>Arrays (Mảng tĩnh):</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">let arr: [i32; 5] = [1, 2, 3, 4, 5]; // Nằm trên Stack</code></pre>

  <h4 class="lesson-section">4. Control Flow: Mọi thứ đều là Expression (Biểu thức)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let condition = true;
    
    // if trả về giá trị, gán thẳng vào biến number
    let number = if condition { 
        5 // KHÔNG CÓ DẤU CHẤM PHẨY
    } else { 
        6 
    }; // Dấu chấm phẩy kết thúc lệnh let

    println!("Number is: {}", number);
}</code></pre>

  <h4 class="lesson-section">5. Loops: 3 chàng lính ngự lâm</h4>
  <div class="lesson-loop">
    <p><strong>A. loop</strong></p>
    <pre class="lesson-code"><code class="lesson-code-rust">loop {
    println!("Chạy mãi mãi...");
    break;
}</code></pre>

    <p><strong>B. while</strong></p>
    <pre class="lesson-code"><code class="lesson-code-rust">let mut n = 3;
while n != 0 {
    println!("{}!", n);
    n -= 1;
}</code></pre>

    <p><strong>C. for (mạnh mẽ nhất)</strong></p>
    <pre class="lesson-code"><code class="lesson-code-rust">for number in 1..4 {
    println!("Số: {}", number);
}</code></pre>
  </div>

  <h4 class="lesson-section">6. Bài tập thực hành: Tính phí Gas (Giả lập)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let limit = 50_000;
    let price = 20; // Gwei

    let fee = calculate_fee(limit, price);
    
    println!("Total Fee: {} Gwei", fee);
}

fn calculate_fee(limit: u64, price: u64) -> u64 {
    const MIN_GAS: u64 = 21_000;

    if limit < MIN_GAS {
        println!("Lỗi: Gas limit quá thấp!");
        0
    } else {
        limit * price
    }
}</code></pre>

  <h3 class="lesson-summary">TỔNG KẾT BÀI 3</h3>
   <div class="lesson-summary-box">
    <ol class="lesson-summary-list">
      <li>Types: Rust rất kỹ tính (u32 khác i32). Hãy tập thói quen dùng <code>u64</code> hoặc <code>usize</code> cho các số đếm/kích thước.</li>
      <li>Overflow: Hãy cẩn thận với cộng trừ nhân chia số nguyên.</li>
      <li>Expression: <code>if</code> là biểu thức trả về giá trị.</li>
      <li>Implicit Return: Dòng cuối cùng không có <code>;</code> chính là return.</li>
    </ol>
  </div>
  <p class="lesson-homework"><strong>Bài tập về nhà:</strong><br>
  Viết chương trình đổi nhiệt độ từ Fahrenheit sang Celsius.<br>
  Công thức: <code>C = (F - 32) / 1.8</code><br>
  Lưu ý: Rust không cho phép cộng trừ int với float tự do như C#. Bạn phải ép kiểu (ví dụ: <code>let f_float = f_int as f64;</code>).</p>

  <p class="lesson-ending">(Hẹn gặp lại ở Chương 2, nơi chúng ta sẽ đối đầu với "Con trùm" của Rust: Ownership & Borrowing. Hãy chuẩn bị tinh thần, vì đây là lúc C# Dev dễ bỏ cuộc nhất!)</p>
</div>