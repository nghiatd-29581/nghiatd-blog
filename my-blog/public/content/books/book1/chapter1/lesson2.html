<div class="lesson-container">
<!-- ====================== NỘI DUNG BÀI 2 ====================== -->
<p class="lesson-intro">
    Chào bạn, nếu Bài 1 là màn khởi động nhẹ nhàng về công cụ,<br>
    thì <strong>Bài 2 này sẽ là “gáo nước lạnh” đầu tiên</strong> mà Rust tạt vào tư duy lập trình C# lâu năm của bạn.
</p>

<h1 class="lesson-part">PHẦN 1: TƯ DUY CỐT LÕI & "CAI NGHIỆN" GC</h1>

<h2 class="lesson-chapter">CHƯƠNG 1: HELLO RUST & TOOLING</h2>
<h3  class="lesson-title">BÀI 2: VARIABLES & MUTABILITY (SỰ KHÁC BIỆT ĐẦU TIÊN)</h3>

<p>Trong C#, biến (variable) sinh ra là để... <strong>biến đổi</strong>.</p>

<pre class="lesson-code"><code class="lesson-code-rust">
// C# Code
int balance = 100;
balance = 200; // Chuyện bình thường ở huyện</code></pre>

<p>Trong Rust, biến sinh ra là để <strong>bất biến</strong>. Nếu bạn viết như trên, trình biên dịch sẽ <strong>hét vào mặt bạn ngay</strong>.</p>

<div class="lesson-warning">
    <p><strong>Tư duy Blockchain:</strong> Hãy tưởng tượng một cuốn sổ cái (Ledger) ngân hàng. Bạn có được phép lấy tẩy xóa số dư cũ và viết đè số mới lên không? <strong>Không.</strong> Một giao dịch đã ghi là bất biến. Sự an toàn của Rust cũng đến từ triết lý tương tự.</p>
</div>

 <h4 class="lesson-section">1. Immutability by Default (Bất biến mặc định)</h4>

<p>Hãy mở VS Code và thử đoạn code này:</p>

<pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let x = 5;
    println!("Giá trị của x là: {}", x);
    
    x = 6; // LỖI SẼ XUẤT HIỆN TẠI ĐÂY
    println!("Giá trị của x là: {}", x);
}</code></pre>

<p>Rust sẽ báo lỗi:</p>
<p class="lesson-warning">
    <code>cannot assign twice to immutable variable <strong>x</strong></code>
</p>

<h4 class="lesson-section">2. Từ khóa <code>mut</code>: Sự thỏa hiệp có kiểm soát</h4>

<pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let mut x = 5; // Chú ý từ khóa 'mut'
    println!("Giá trị của x là: {}", x);
    
    x = 6; // Bây giờ thì hợp lệ
    println!("Giá trị của x là: {}", x);
}</code></pre>

<table class="lesson-table">
    <tr><th>Đặc điểm</th><th>C#</th><th>Rust</th></tr>
    <tr><td>Mặc định</td><td>Có thể thay đổi (Mutable)</td><td>Bất biến (Immutable)</td></tr>
    <tr><td>Muốn bất biến</td><td>Dùng <code>readonly</code> hoặc <code>const</code></td><td>Không làm gì cả (Mặc định)</td></tr>
    <tr><td>Muốn thay đổi</td><td>Không làm gì cả (Mặc định)</td><td>Dùng <code>mut</code></td></tr>
</table>

<h4 class="lesson-section">3. Shadowing (Cái bóng): Siêu năng lực mà C# không có</h4>

<p>Trong C#, bạn <strong>không thể</strong> khai báo 2 biến cùng tên trong cùng scope:</p>

<pre class="lesson-code"><code class="lesson-code-rust">// C# - Lỗi ngay lập tức
string data = "123";
int data = int.Parse(data); // Lỗi: 'data' is already defined</code></pre>

<p>Trong Rust, bạn được phép. Đây là kỹ thuật cực kỳ phổ biến để chuyển đổi kiểu dữ liệu.</p>

<pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let spaces = "   ";              // String
    
    let spaces = spaces.len();       // usize - biến cũ bị "che khuất"
    
    println!("Số lượng dấu cách: {}", spaces);
}</code></pre>

<div class="lesson-tip ">
    <strong>Phân tích:</strong><br>
    • <code>mut</code> = thay đổi giá trị của cùng một biến (cùng kiểu)<br>
    • <code>let</code> lại = tạo biến mới, có thể khác kiểu → biến cũ "chết"
</div>

<h4 class="lesson-section">4. Hằng số (<code>const</code>): Sự nghiêm khắc tuyệt đối</h4>

<pre class="lesson-code"><code class="lesson-code-rust">// Đúng chuẩn Rust
const MAX_POINTS: u32 = 100_000; // Phải khai báo kiểu!</code></pre>

<h4 class="lesson-section">5. Bài tập thực hành: Mô phỏng ví tiền (Crypto Wallet)</h4>

<pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    // 1. Số dư khởi tạo (Immutable - an toàn)
    let start_balance = 1000;
    
    // 2. Tạo ví có thể thay đổi
    let mut wallet = start_balance;
    println!("Số dư ban đầu: {}", wallet);
    
    // 3. Nhận Airdrop
    let airdrop = 500;
    wallet += airdrop;
    println!("Sau khi nhận Airdrop: {}", wallet);
    
    // 4. Shadowing: Chuyển sang dạng hiển thị
    let wallet = format!("{} USD", wallet);
    
    println!("Số dư hiển thị: {}", wallet);
    
    // wallet += 10; // LỖI! Giờ wallet là String
}</code></pre>

<h3 class="lesson-summary">TỔNG KẾT BÀI 2</h3>
<p>Một C# Developer giỏi khi chuyển sang Rust cần nhớ <strong>"Thần chú"</strong> sau:</p>
<div class="lesson-summary-box">
    <ol class="lesson-summary-list">
        <li>Mặc định là khóa (<strong>Immutable</strong>): Đừng mở khóa (<strong>mut</strong>) trừ khi thực sự cần.</li>
        <li><strong>Shadowing</strong> là bạn: Dùng nó để chuyển đổi kiểu dữ liệu, code sạch như mơ.</li>
        <li>Trình biên dịch là <strong>cảnh sát</strong>: Nó báo lỗi = đang bảo vệ bạn khỏi bug tương lai.</li>
    </ol>
</div>

<div class="lesson-homework">
    <p>
        <strong>Bài tập về nhà:</strong><br>
        Viết chương trình tính lãi suất kép:<br>
        • <code>const LAI_SUAT: f64 = 0.05;</code><br>
        • Dùng <code>let mut nam = 1;</code><br>
        • Tăng năm lên, tính lãi kép<br>
        • Cuối cùng dùng <strong>Shadowing</strong> để chuyển kết quả thành chuỗi đẹp.
    </p>
</div>
<p class="lesson-ending">
    Hẹn gặp lại ở Bài 3:<br>
    Primitive Types – Tại sao Rust có tới 6 loại số nguyên<br>
    và tại sao C# Dev hay… chọn sai loại?
</p>

</div> <!-- END .lesson2-rust -->
