<div class="lesson-container">
  <p class="lesson-intro">Chào mừng bạn trở lại. Ở Bài 4, chúng ta đã học về <strong>Ownership</strong> với quy tắc nghiệt ngã: <em>“Đã cho đi là mất luôn”</em> (Move semantics).<br><br>
  Nhưng trong thực tế, chẳng lẽ mỗi lần muốn đếm xem trong ví có bao nhiêu tiền (gọi hàm count_money), ta lại phải đưa luôn cái ví cho người đếm và mất quyền sở hữu nó? Điều đó thật vô lý.<br><br>
  <strong>C#</strong> giải quyết bằng cách cho phép nhiều biến cùng trỏ vào một Object (với sự bảo trợ của GC).<br>
  <strong>Rust</strong> giải quyết bằng cơ chế <strong>Borrowing (Vay mượn)</strong> – thông minh hơn, an toàn hơn, và không cần GC.</p>

  <h1 class="lesson-part">PHẦN 1: TƯ DUY CỐT LÕI & "CAI NGHIỆN" GC</h1>
  <h2 class="lesson-chapter">CHƯƠNG 2: OWNERSHIP & BORROWING - "LINH HỒN" CỦA RUST</h2>
  <h3 class="lesson-title">BÀI 5: BORROWING & REFERENCES <span class="lesson-subtitle">(VAY MƯỢN & THAM CHIẾU)</span></h3>

  <p class="lesson-list">Nguyên tắc cốt lõi:<br>
  Nếu bạn muốn dùng dữ liệu mà <strong>không muốn nhận quyền sở hữu</strong>, bạn hãy <strong>mượn nó</strong> thông qua <strong>Tham chiếu (Reference)</strong>.<br>
  Tham chiếu giống như một con trỏ, nhưng <strong>luôn được đảm bảo trỏ đến dữ liệu hợp lệ</strong> (không bao giờ null).<br>
  Ký hiệu: <code>&</code> và <code>&mut</code></p>

  <h4 class="lesson-section">1. Immutable References (Mượn để xem)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // Truyền tham chiếu, không move

    println!("Độ dài của '{}' là {}.", s1, len); // s1 vẫn dùng được!
}

fn calculate_length(s: &String) -> usize { 
    s.len()
} // Không có ownership → dữ liệu gốc KHÔNG bị drop</code></pre>
  <p class="lesson-highlight">So sánh:<br>
  • C#: Mọi biến class đều là tham chiếu → nhưng không biết hàm có sửa dữ liệu không.<br>
  • Rust: <code>&T</code> = <strong>Read-Only</strong>. Compiler chặn ngay nếu cố sửa.</p>
  <p class="lesson-rule">Quy tắc vàng: Có thể tạo <strong>vô số &T</strong> cùng lúc (như Google Docs ở chế độ View Only).</p>

  <h4 class="lesson-section">2. Mutable References (Mượn để sửa)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let mut s = String::from("hello");

    change(&mut s); // Truyền tham chiếu mutable
    
    println!("Sau khi đổi: {}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}</code></pre>

  <h4 class="lesson-section">3. "Luật Rừng" của Borrow Checker (QUAN TRỌNG NHẤT)</h4>
  <div class="lesson-borrow-rules">
    <p class="lesson-rule-title">Tại một thời điểm, bạn chỉ được phép có:</p>
    <div class="lesson-rule-item active">HOẶC: Vô số tham chiếu đọc (<code>&T</code>)</div>
    <div class="lesson-rule-item active">HOẶC: DUY NHẤT một tham chiếu ghi (<code>&mut T</code>)</div>
    <div class="lesson-rule-item forbidden">KHÔNG ĐƯỢC tồn tại cả hai cùng lúc!</div>
  </div>

  <p class="lesson-warning">Ví dụ lỗi 1: Hai người cùng sửa</p>
  <pre class="lesson-code"><code class="lesson-code-rust">let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s; // LỖI BIÊN DỊCH</code></pre>

  <p class="lesson-warning">Ví dụ lỗi 2: Đang đọc thì bị sửa</p>
  <pre class="lesson-code"><code class="lesson-code-rust">let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &mut s; // LỖI: cannot borrow as mutable because it is also borrowed as immutable</code></pre>

  <p class="lesson-analogy">Ẩn dụ hay nhất:<br>
  Dữ liệu là một <strong>Bảng Ghi Chú</strong>:<br>
  • <code>&T</code>: Mọi người được nhìn bảng → không ai được cầm bút.<br>
  • <code>&mut T</code>: Chỉ <strong>một người duy nhất</strong> được cầm bút viết → tất cả phải quay mặt đi.</p>

  <h4 class="lesson-section">4. Dangling References (Tham chiếu treo) – Rust nói KHÔNG</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn dangle() -> &String {
    let s = String::from("hello");
    &s // Trả về tham chiếu tới s
} // s bị drop → tham chiếu trỏ vào hư không → LỖI BIÊN DỊCH!</code></pre>
  <p class="lesson-success">Rust sẽ mắng bạn ngay:<br>
  <em>“this function's return type contains a borrowed value, but the borrowed value has been dropped”</em></p>

  <h4 class="lesson-section">5. Bài tập thực hành: Hệ thống Account (C# vs Rust)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">struct Account {
    owner: String,
    balance: u64,
}

fn main() {
    let mut my_acc = Account {
        owner: String::from("Alice"),
        balance: 100,
    };

    show_balance(&my_acc);     // Đọc → OK
    show_balance(&my_acc);     // Đọc lần 2 → OK

    deposit(&mut my_acc, 50);  // Sửa → OK

    // let r = &my_acc;
    // deposit(&mut my_acc, 20); // LỖI nếu r còn sống
}

fn show_balance(acc: &Account) {
    println!("User {} has ${}", acc.owner, acc.balance);
}

fn deposit(acc: &mut Account, amount: u64) {
    acc.balance += amount;
    println!("Deposited ${}. New balance: ${}", amount, acc.balance);
}</code></pre>

  <h3 class="lesson-summary">TỔNG KẾT BÀI 5</h3>
  <div class="lesson-summary-box">
    <ol class="lesson-summary-list">
      <li><strong>Reference (&)</strong>: Dùng dữ liệu mà không lấy ownership.</li>
      <li><strong>&T</strong>: Nhiều người cùng đọc → không ai được sửa.</li>
      <li><strong>&mut T</strong>: Một người độc quyền sửa → không ai được đọc.</li>
      <li><strong>No Dangling Pointers</strong>: Tham chiếu luôn sống ngắn hơn dữ liệu gốc.</li>
    </ol>
  </div>

  <div class="lesson-advice">
    <p><strong>Lời khuyên vàng cho C# Dev khi viết hàm trong Rust:</strong></p>
    <ol class="lesson-advice-list">
      <li>Có cần sửa dữ liệu không? → <strong>Không</strong> → Dùng <code>&T</code></li>
      <li>Có cần sửa dữ liệu không? → <strong>Có</strong> → Dùng <code>&mut T</code></li>
      <li>Có cần dữ liệu sống lâu hơn scope hiện tại? → <strong>Có</strong> → Dùng <code>T</code> (Move)</li>
    </ol>
  </div>

  <div class="lesson-homework">
    <p><strong>Bài tập về nhà:</strong><br>
    Viết 2 hàm:<br>
    • <code>calculate_interest(balance: &u64) -> u64</code> (tính lãi 10%)<br>
    • <code>add_interest(balance: &mut u64)</code> (gọi hàm trên rồi cộng vào số dư)</p>
  </div>

  <p class="lesson-ending">
    (Hẹn gặp lại ở <strong>Bài 6: The Slice Type</strong>.<br>
    Chúng ta sẽ học cách tham chiếu đến <em>“một phần”</em> của chuỗi hoặc mảng mà <strong>không cần copy dữ liệu</strong> – bí quyết tối ưu bộ nhớ đỉnh cao của Rust.)
  </p>
</div>