<div class="lesson-container">
  <p class="lesson-intro">Chào mừng bạn đến với <strong>Chương 2</strong>. Nếu các bài trước là "khởi động" thì đây là <strong>"vượt chướng ngại vật"</strong>.<br>
  Trong C#, bạn có một "người giúp việc" cần mẫn tên là <strong>Garbage Collector (GC)</strong>. Bạn cứ việc <code>new Object()</code>, dùng xong thì vứt đó, GC sẽ đi sau dọn dẹp. Cuộc sống thật dễ dàng, nhưng nó phải trả giá bằng hiệu năng (GC pause) và khó kiểm soát thời điểm giải phóng bộ nhớ.<br><br>
  <strong>Rust sa thải "người giúp việc" này.</strong> Rust trao quyền (và trách nhiệm) quản lý bộ nhớ lại cho bạn, nhưng thông qua một bộ luật nghiêm ngặt gọi là <strong>Ownership</strong>.</p>

  <h1 class="lesson-part">PHẦN 1: TƯ DUY CỐT LÕI & "CAI NGHIỆN" GC</h1>
  <h2 class="lesson-chapter">CHƯƠNG 2: OWNERSHIP & BORROWING - "LINH HỒN" CỦA RUST</h2>
  <h3 class="lesson-title">BÀI 4: OWNERSHIP <span class="lesson-subtitle">(QUYỀN SỞ HỮU)</span></h3>

  <p class="lesson-text">Trong bài này, chúng ta sẽ trả lời câu hỏi: <strong>Làm thế nào Rust đảm bảo an toàn bộ nhớ mà không cần GC?</strong></p>

  <h4 class="lesson-section">1. Stack và Heap: Ôn lại một chút</h4>
  <ul class="lesson-list">
    <li><strong>Stack (Ngăn xếp):</strong> Nhanh, kích thước cố định, LIFO. Chứa các kiểu dữ liệu đơn giản (int, bool, char).</li>
    <li><strong>Heap (Vùng nhớ đống):</strong> Chậm hơn, kích thước linh động. Chứa dữ liệu phức tạp (String, Vector, Object). Cần một "con trỏ" từ Stack trỏ sang Heap.</li>
  </ul>
  <p class="lesson-text">Trong C#: <code>int x = 10;</code> → Stack<br>
  <code>var user = new User();</code> → tham chiếu trên Stack, dữ liệu thật trên Heap.</p>
  <p class="lesson-highlight">Trong Rust cũng vậy, nhưng <strong>cách quản lý vòng đời của dữ liệu trên Heap thì hoàn toàn khác</strong>.</p>

  <h4 class="lesson-section">2. Ba Nguyên Tắc Vàng của Ownership</h4>
  <div class="lesson-rules">
    <div class="lesson-rule">1. Mỗi giá trị trong Rust đều có một biến gọi là <strong>Owner</strong> (Chủ sở hữu).</div>
    <div class="lesson-rule">2. Tại một thời điểm, <strong>chỉ có duy nhất một Owner</strong>.</div>
    <div class="lesson-rule">3. Khi Owner đi ra khỏi phạm vi (out of scope), giá trị sẽ bị <strong>hủy (dropped) ngay lập tức</strong>.</div>
  </div>
  <p class="lesson-note">Compiler của Rust hoạt động hoàn toàn dựa trên 3 nguyên tắc này.</p>

  <h4 class="lesson-section">3. Phạm vi (Scope) & Drop</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">{                      // Bắt đầu scope
    let s = "hello";   // s có giá trị từ đây
    // làm gì đó với s
}                      // Kết thúc scope → s bị HỦY ngay lập tức</code></pre>
  <p class="lesson-text">Trong C#: biến tham chiếu mất, object vẫn còn chờ GC.<br>
  <strong>Trong Rust:</strong> tự động gọi <code>drop()</code> → giải phóng bộ nhớ Heap <strong>ngay lập tức</strong>. Không rác thừa, không chờ đợi.</p>

  <h4 class="lesson-section">4. Move Semantics: Cú sốc đầu tiên (Quan trọng nhất)</h4>
  <p class="lesson-text"><strong>Trường hợp 1: Dữ liệu trên Stack (Primitive Types)</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">let x = 5;
let y = x; 
// Cả x và y đều = 5 → Rust COPY giá trị (giống C#)</code></pre>

  <p class="lesson-text"><strong>Trường hợp 2: Dữ liệu trên Heap (String)</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">let s1 = String::from("hello");
let s2 = s1; 

println!("{}, world!", s1); // LỖI: value borrowed here after move</code></pre>
  <p class="lesson-warning">Tại sao lỗi?<br>
  → Khi gán <code>s2 = s1</code>, Rust <strong>chuyển quyền sở hữu (MOVE)</strong> từ s1 sang s2.<br>
  → <code>s1</code> bị vô hiệu hóa (invalid) → tránh lỗi <strong>Double Free</strong>.</p>

  <p class="lesson-text"><strong>Giải pháp: Clone (Deep Copy)</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">let s1 = String::from("hello");
let s2 = s1.clone(); // Copy toàn bộ dữ liệu

println!("s1 = {}, s2 = {}", s1, s2); // OK</code></pre>

  <h4 class="lesson-section">5. Ownership và Functions (Hàm)</h4>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let s = String::from("hello");

    takes_ownership(s);     // s bị MOVE vào hàm → không dùng được nữa!

    let x = 5;
    makes_copy(x);          // x là Copy type → vẫn dùng được
    println!("{}", x);      // OK
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // → drop() được gọi tự động

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}</code></pre>

  <h4 class="lesson-section">6. Tóm tắt so sánh C# vs Rust</h4>
  <table class="lesson-table">
    <thead>
      <tr>
        <th>Hành động</th>
        <th>C# (.NET)</th>
        <th>Rust</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>Gán biến Heap (b = a)</td><td>Copy tham chiếu</td><td><strong>Move</strong> (a chết)</td></tr>
      <tr><td>Gán biến Stack</td><td>Copy giá trị</td><td>Copy giá trị</td></tr>
      <tr><td>Hết Scope</td><td>Chờ GC</td><td><strong>Drop ngay lập tức</strong></td></tr>
      <tr><td>Truyền vào hàm</td><td>Tham chiếu hoặc giá trị</td><td><strong>Move</strong> (trừ Copy trait)</td></tr>
    </tbody>
  </table>

  <h4 class="lesson-section">7. Bài tập thực hành: Sửa lỗi Ownership</h4>
  <p class="lesson-text"><strong>Code lỗi:</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">fn main() {
    let token_name = String::from("Bitcoin");
    
    print_token(token_name);
    
    println!("Token confirmed: {}", token_name); // LỖI
}

fn print_token(name: String) {
    println!("Processing: {}", name);
}</code></pre>

  <p class="lesson-text"><strong>Lời giải (Cách 1 - Dùng clone):</strong></p>
  <pre class="lesson-code"><code class="lesson-code-rust">print_token(token_name.clone()); // Đưa bản sao
println!("Token confirmed: {}", token_name); // Giờ thì OK!</code></pre>

  <h3 class="lesson-summary">KẾT LUẬN BÀI 4</h3>
  <div class="lesson-summary-box">
    <p>Ownership giống như việc trao tay tiền mặt ngoài đời thực:</p>
    <ul class="lesson-summary-list">
      <li>Nếu tôi đưa tờ 500k cho bạn (<strong>Move</strong>), tôi không còn nữa.</li>
      <li>Muốn cả hai cùng có → phải <strong>photo màu (clone)</strong> – tốn kém.</li>
      <li>int, bool giống như email → gửi đi vẫn còn bản gốc (<strong>Copy</strong>).</li>
    </ul>
  </div>
    <p class="lesson-ending">Ở bài tiếp theo, chúng ta sẽ học cách <strong>"cho mượn tiền"</strong> mà không cần "cho luôn". Đó là <strong>References & Borrowing</strong>.<br>
    <em>(Bạn đã hiểu tại sao tôi gọi Rust là ngôn ngữ kỷ luật chưa? Hãy nghỉ ngơi một chút trước khi sang Bài 5 nhé!)</em></p>
  
</div>