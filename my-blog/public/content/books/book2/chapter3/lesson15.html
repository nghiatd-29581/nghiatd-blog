<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bài 15: Data Lifecycle & Compliance – Trần's Blog</title>
</head>
<body>

<div class="lesson-container">
  <p class="lesson-intro">
    Chào bạn! Chúng ta đã cùng nhau xây dựng "trái tim" hệ thống qua việc chọn Database, Indexing và Modeling.<br> Nhưng có một thực tế là: Trái tim ấy không thể cứ phình to mãi mãi. Dữ liệu giống như đồ đạc trong nhà, nếu bạn không có kế hoạch dọn dẹp, phân loại hoặc bỏ bớt, sớm muộn gì bạn cũng sẽ không còn chỗ để thở (và ví tiền của bạn cũng sẽ "cạn kiệt" vì chi phí lưu trữ).<br>
    Hôm nay, chúng ta sẽ bàn về Hậu cần (Logistics) của dữ liệu: Làm sao để lưu trữ thông minh và làm sao để xóa dữ liệu mà không bị... cảnh sát hỏi thăm (Compliance). <br>Hãy thắt dây an toàn, bài này sẽ rất "đắt giá" theo cả nghĩa đen lẫn nghĩa bóng!
  </p>

  <h1 class="lesson-part">PHẦN 3: STORAGE & DATA MODELING</h1>
  <h2 class="lesson-chapter">CHƯƠNG 3: THẾ GIỚI DATABASE</h2>
  <h3 class="lesson-title">BÀI 15: DATA LIFECYCLE & COMPLIANCE</h3>
    <h3 class="lesson-title">NGHỆ THUẬT "DỌN NHÀ" VÀ LUẬT CHƠI TOÀN CẦU</h3>

  <h4 class="lesson-section">1. Data Lifecycle: Chiến thuật Hot / Warm / Cold Storage</h4>

  <p class="lesson-text">Trong System Design, chúng ta không gọi chung là "ổ cứng". Chúng ta chia dữ liệu theo "nhiệt độ" (Temperature) để tối ưu hóa chi phí và hiệu năng.</p>

  <p class="lesson-text"><strong>1.1. Hot Storage (Dữ liệu Nóng)</strong></p>
  <p class="lesson-text">Đây là dữ liệu được truy cập liên tục, yêu cầu độ trễ (Latency) thấp nhất có thể (tính bằng ms).</p>
  <ul class="lesson-list">
    <li>Vũ khí: RAM (Redis/Memcached), SSD/NVMe (PostgreSQL/MySQL).</li>
    <li>Đặc điểm: Chi phí rất đắt.</li>
    <li>Ví dụ: Session đăng nhập, giỏ hàng hiện tại, các bài đăng đang trending trên TikTok.</li>
  </ul>

  <p class="lesson-text"><strong>1.2. Warm Storage (Dữ liệu Ấm)</strong></p>
  <p class="lesson-text">Dữ liệu ít dùng hơn nhưng khi cần thì vẫn phải có trong vài giây.</p>
  <ul class="lesson-list">
    <li>Vũ khí: HDD tốc độ cao, hoặc các loại Object Storage cấu hình thấp.</li>
    <li>Đặc điểm: Chi phí trung bình.</li>
    <li>Ví dụ: Ảnh bạn đã đăng tháng trước, lịch sử giao dịch trong vòng 90 ngày.</li>
  </ul>

  <p class="lesson-text"><strong>1.3. Cold Storage (Dữ liệu Lạnh)</strong></p>
  <p class="lesson-text">Dữ liệu "đắp chiếu", cả năm may ra mới sờ đến một lần, chủ yếu lưu để đối soát hoặc theo yêu cầu pháp luật.</p>
  <ul class="lesson-list">
    <li>Vũ khí: Amazon S3 Glacier, Google Cloud Archive, hoặc thậm chí là... băng từ (Magnetic Tape).</li>
    <li>Đặc điểm: Rẻ như cho, nhưng để lấy dữ liệu ra có khi mất vài giờ đến vài ngày.</li>
    <li>Ví dụ: Log hệ thống của 3 năm trước, dữ liệu thuế, sao lưu (Backup) dự phòng thảm họa.</li>
  </ul>

  <h4 class="lesson-section">2. GDPR & Right to be Forgotten: Khi "Xóa" không đơn giản là DELETE</h4>

  <p class="lesson-text">Nếu bạn nghĩ xóa dữ liệu là chạy lệnh DELETE FROM users WHERE id = 1 thì bạn lầm to rồi. Trong kỷ nguyên GDPR (General Data Protection Regulation) của EU, người dùng có "Quyền được quên" (Right to be Forgotten).</p>

  <p class="lesson-text"><strong>Những thách thức khiến Architect "mất ngủ":</strong></p>
  <ol class="lesson-list">
    <li>Dữ liệu rải rác: Bạn xóa ở Database chính, nhưng nó còn nằm ở: Cache (Redis), Data Warehouse (BigQuery), Log file, và hàng trăm bản Backup hàng ngày.</li>
    <li>Dữ liệu phái sinh: Nếu người dùng đó đã từng đánh giá (Review) sản phẩm, bạn có xóa Review đó không? Nếu xóa, điểm trung bình của sản phẩm có bị sai lệch không?</li>
    <li>Hàng đợi (Message Queue): Request xóa đang nằm trong Kafka, nhưng Consumer đang bị lag chưa xử lý kịp.</li>
  </ol>

  <p class="lesson-text"><strong>Giải pháp thiết kế "Sạch":</strong></p>
  <ul class="lesson-list">
    <li>Soft Delete vs Hard Delete: Ban đầu dùng Flag is_deleted = true (Soft Delete) để người dùng có thể khôi phục. Sau 30 ngày, hệ thống tự động chạy một Job ngầm để thực hiện Hard Delete (xóa vĩnh viễn).</li>
    <li>Crypto-shredding (Xóa bằng mã hóa): Đây là kỹ thuật cực kỳ thông minh. Mỗi người dùng có một khóa mã hóa (Encryption Key) riêng. Khi họ yêu cầu "quên tôi đi", bạn chỉ cần xóa cái khóa đó. Dữ liệu vẫn còn đó nhưng giờ đây nó là một đống rác vô nghĩa không ai đọc được. Đây là cách nhanh nhất để "xóa" dữ liệu trong các bản Backup cũ mà bạn không thể can thiệp được.</li>
  </ul>

  <h4 class="lesson-section">3. Data Retention Policy: "Tấm kim bài" miễn tử</h4>

  <p class="lesson-text">Đừng đợi đến khi ổ cứng đầy mới cuống cuồng đi xóa. Một Architect giỏi phải thiết lập Chính sách lưu trữ (Retention Policy) ngay từ ngày đầu.</p>

  <ul class="lesson-list">
    <li>TTL (Time To Live): Thiết lập cho mỗi bản ghi một "tuổi thọ". Ví dụ: Log hệ thống chỉ sống 7 ngày, sau đó tự động biến mất. NoSQL như Cassandra hay Redis hỗ trợ cái này cực tốt.</li>
    <li>Archiving Job: Định kỳ mỗi tháng, một tiến trình sẽ quét Database chính, hốt tất cả dữ liệu "nguội" (trên 1 năm) và đẩy sang S3 Glacier.</li>
  </ul>

  <h4 class="lesson-section">4. Ví dụ thực chiến: Hệ thống lưu trữ tin nhắn Chat</h4>

  <p class="lesson-text">Hãy xem cách một Master thiết kế vòng đời cho tin nhắn của bạn:</p>

  <ol class="lesson-list">
    <li>0 - 7 ngày: Tin nhắn nằm trong RAM/SSD xịn (Hot). Bạn mở app ra là thấy ngay lập tức.</li>
    <li>8 - 365 ngày: Tin nhắn được nén lại, đẩy xuống HDD/S3 (Warm). Khi bạn cuộn trang (Scroll) mỏi tay về năm ngoái, nó sẽ hiện cái vòng quay "Loading" một chút rồi mới ra.</li>
    <li>Trên 1 năm: Đưa vào Archive (Cold). Nếu bạn muốn xem, hệ thống báo: "Vui lòng đợi chúng tôi chuẩn bị lại lịch sử chat cũ".</li>
    <li>Khi bạn xóa tài khoản: Hệ thống kích hoạt Crypto-shredding, hủy khóa của bạn. Dù 5 năm sau cảnh sát có thu giữ ổ cứng Backup, họ cũng không xem được bạn đã nhắn gì cho "crush".</li>
  </ol>

  <h3 class="lesson-summary">TỔNG KẾT BÀI 15</h3>

  <div class="lesson-summary-box">
    <p class="lesson-text">Kết thúc Chương 3 về Storage, bạn cần nhớ:</p>
    <ol class="lesson-list">
      <li>Tiền là hữu hạn, dữ liệu là vô hạn: Hãy phân loại Hot/Warm/Cold để cứu lấy ví tiền của sếp.</li>
      <li>Compliance là sống còn: Hãy thiết kế hệ thống có khả năng xóa sạch dữ liệu từ đầu. Đừng để đến lúc bị phạt mới đi "vá".</li>
      <li>Tự động hóa: Mọi quy trình di chuyển hay xóa dữ liệu phải được thực hiện bằng Script/Job, đừng dùng tay.</li>
    </ol>
    <p class="lesson-text"><strong>Nguồn tham khảo:</strong></p>
    <ul class="lesson-list">
      <li>GDPR Official Text (Article 17: Right to erasure).</li>
      <li>Google Cloud Architecture Framework: Data Lifecycle Management.</li>
    </ul>
  </div>

  <p class="lesson-ending">
    Tạm biệt Chương 3 - Chào mừng Chương 4: INFRASTRUCTURE & CLOUD-NATIVE<br>
    Chúng ta đã xong phần "Nội tạng" (Dữ liệu). Bây giờ là lúc chúng ta xây dựng "Bộ khung" và "Hệ thống giao thông" để vận hành cả cơ thể đó.<br>
    Bài 16: Load Balancing – Nghệ thuật điều phối giao thông. Làm sao để khi 1 triệu người cùng ập vào, hệ thống không bị "tắc đường"? Làm sao để biết Server nào đang rảnh, Server nào đang "thở oxy"?<br>
    Câu hỏi nhỏ cho bạn: Bạn đã bao giờ tự hỏi các sàn TMĐT lưu trữ hóa đơn của bạn trong bao lâu chưa? Họ có xóa chúng sau 10 năm không, hay vẫn giữ đó để làm Big Data? Hãy chia sẻ suy nghĩ của bạn nhé!<br>
    Bạn thấy bài viết về "Hậu cần dữ liệu" này thế nào? Đã đủ chi tiết và thực tế chưa? Nếu bạn đã sẵn sàng bước sang chương hạ tầng (Infrastructure), hãy cho tôi biết nhé!
  </p>
</div>

</body>
</html>