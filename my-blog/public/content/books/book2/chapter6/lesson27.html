<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bài 27: Observability – Trần's Blog</title>
</head>
<body>

<div class="lesson-container">
  <p class="lesson-intro">
    Chào mừng bạn đã vượt qua "cửa ải" Chương 5 với những kiến thức về giao tiếp và bảo mật. <br>Bây giờ, hãy hít một hơi thật sâu, vì chúng ta đang bước vào Chương 6: RESILIENCE & OBSERVABILITY.<br>
    Nếu các chương trước dạy bạn cách xây dựng một hệ thống chạy được, thì chương này sẽ dạy bạn cách xây dựng một hệ thống "bất tử". <br>Trong thế giới Microservices, câu hỏi không phải là "Hệ thống có sập hay không?" mà là "Khi nào nó sập và chúng ta sẽ đối phó thế nào?".<br>
    Mời bạn cùng bước vào bài viết chi tiết nhất về những "tấm khiên" bảo vệ hệ thống.
  </p>

  <h2 class="lesson-chapter">CHƯƠNG 6: RESILIENCE & OBSERVABILITY</h2>
  <h3 class="lesson-title">BÀI 27: OBSERVABILITY</h3>
  <h3 class="lesson-title">ĐỪNG CHỈ NHÌN, HÃY THẤU HIỂU HỆ THỐNG</h3>

  <h4 class="lesson-section">1. Monitoring vs. Observability: Khác biệt giữa "Kết quả" và "Nguyên nhân"</h4>

  <p class="lesson-text">Đây là câu hỏi kinh điển để phân biệt giữa một Junior và một Senior Architect.</p>

  <ul class="lesson-list">
    <li><strong>Monitoring (Giám sát):</strong> Trả lời câu hỏi "Cái gì đang xảy ra?". Nó dựa trên các chỉ số đã biết trước (Known unknowns).<br>
      - Ví dụ: CPU > 80%? Có. Tỷ lệ lỗi > 5%? Có. Hệ thống còn sống không? Còn.<br>
      - Công cụ: Zabbix, Nagios, các bảng Dashboard tĩnh.</li>
    <li><strong>Observability (Khả năng quan sát):</strong> Trả lời câu hỏi "Tại sao nó lại xảy ra?". Nó cho phép bạn đặt những câu hỏi mà bạn chưa từng nghĩ tới (Unknown unknowns).<br>
      - Ví dụ: "Tại sao 0.1% người dùng dùng trình duyệt Safari ở vùng Đông Nam Á lại gặp lỗi 500 khi mua món hàng có ID là 99?"<br>
      - Bản chất: Observability là một thuộc tính của hệ thống. Bạn không "mua" được Observability, bạn phải "xây dựng" nó vào trong code.</li>
  </ul>

  <p class="lesson-text"><strong>Góc hài hước:</strong> Monitoring giống như việc bạn nhìn vào nhiệt kế và thấy mình đang 39 độ (Biết là sốt). Observability là việc bạn đi xét nghiệm máu, chụp CT và bác sĩ bảo: "À, bạn sốt vì con vi khuẩn X đang tấn công vào tế bào Y" (Hiểu tại sao sốt).</p>

  <h4 class="lesson-section">2. Ba trụ cột của Observability (The Three Pillars)</h4>

  <p class="lesson-text">Để đạt được "cảnh giới" thấu hiểu hệ thống, bạn cần sự phối hợp nhịp nhàng của 3 loại dữ liệu: Metrics, Logs, và Tracing.</p>

  <p class="lesson-text"><strong>2.1. Metrics (Các con số biết nói)</strong></p>
  <p class="lesson-text">Metrics là dữ liệu dạng số được tổng hợp theo thời gian. Chúng cực kỳ nhẹ và phù hợp để làm Dashboard hoặc Alert.</p>

  <ul class="lesson-list">
    <li><strong>Các loại chính:</strong>
      <ul class="lesson-list">
        <li>Counter: Chỉ tăng (ví dụ: Tổng số request).</li>
        <li>Gauge: Có thể tăng hoặc giảm (ví dụ: Số lượng Thread đang chạy, lượng RAM sử dụng).</li>
        <li>Histogram/Summary: Đo lường phân phối (ví dụ: 99% request (p99) hoàn thành dưới 200ms).</li>
      </ul>
    </li>
    <li><strong>Điểm yếu:</strong> Metrics không có Context. Bạn thấy p99 tăng vọt, nhưng bạn không biết request cụ thể nào là kẻ tội đồ.</li>
    <li><strong>Công cụ:</strong> Prometheus, VictoriaMetrics, Grafana.</li>
  </ul>

  <p class="lesson-text"><strong>2.2. Logs (Cuốn nhật ký chi tiết)</strong></p>
  <p class="lesson-text">Logs là bản ghi về các sự kiện rời rạc. Đây là nơi bạn ghi lại những thông tin chi tiết nhất như: "User ID 1 vừa đổi mật khẩu từ IP 1.1.1.1".</p>

  <ul class="lesson-list">
    <li><strong>Nguyên tắc Master:</strong> Hãy dùng Structured Logging (JSON format). Đừng bao giờ log kiểu: Log.Info("User " + id + " logged in"). Hãy log kiểu: {"event": "login", "user_id": 1, "status": "success"}. Máy tính thích JSON, và các công cụ search logs cũng vậy.</li>
    <li><strong>Điểm yếu:</strong> Logs cực kỳ tốn dung lượng đĩa cứng. Nếu bạn log quá nhiều trong hệ thống High Traffic, tiền lưu trữ log sẽ đắt hơn tiền chạy server.</li>
    <li><strong>Công cụ:</strong> ELK Stack (Elasticsearch, Logstash, Kibana), Grafana Loki.</li>
  </ul>

  <p class="lesson-text"><strong>2.3. Tracing (Bản đồ hành trình - Quan trọng nhất!)</strong></p>
  <p class="lesson-text">Tracing cho phép bạn theo dõi một Request duy nhất khi nó "chu du" qua các Microservices.</p>

  <ul class="lesson-list">
    <li><strong>Cơ chế:</strong> Khi request đi vào cửa ngõ (API Gateway), hệ thống gắn cho nó một cái TraceID. Khi Service A gọi Service B, nó truyền TraceID này qua Header.</li>
    <li><strong>Span:</strong> Mỗi chặng dừng tại một Service được gọi là một Span. Một Trace là tập hợp của nhiều Span.</li>
    <li><strong>Tác dụng:</strong> Bạn nhìn vào Trace và thấy ngay: Request mất 2s, trong đó 1.9s là do thằng Database của Service C đang bị "táo bón".</li>
    <li><strong>Công cụ:</strong> Jaeger, Zipkin, Tempo.</li>
  </ul>

  <h4 class="lesson-section">3. OpenTelemetry (OTel): Chuẩn mực chung của thế giới</h4>

  <p class="lesson-text">Ngày xưa, nếu bạn dùng Jaeger thì phải cài thư viện của Jaeger, dùng DataDog phải cài thư viện của DataDog. Nếu muốn đổi công cụ? Bạn phải sửa code cả nghìn chỗ. Cực hình!</p>

  <p class="lesson-text">OpenTelemetry ra đời để chấm dứt sự hỗn loạn đó. Nó là một dự án của CNCF cung cấp một bộ SDK và API chuẩn để thu thập cả 3 loại dữ liệu (Metrics, Logs, Traces).</p>

  <ul class="lesson-list">
    <li><strong>Vendor-neutral:</strong> Bạn code một lần với OTel, hôm nay bạn đẩy dữ liệu về Grafana, ngày mai bạn đổi sang New Relic hay Honeycomb chỉ bằng cách thay đổi cấu hình, không cần sửa code.</li>
    <li><strong>OTel Collector:</strong> Một "trạm trung chuyển" dữ liệu mạnh mẽ, giúp lọc, nén và đẩy dữ liệu về nhiều nơi cùng lúc.</li>
  </ul>

  <h4 class="lesson-section">4. Đào sâu: High Cardinality và Nỗi đau của người làm vận hành</h4>

  <p class="lesson-text">Đây là phần "nặng đô" cho các bạn muốn làm Lead. Khi thiết kế Observability, bạn sẽ gặp vấn đề về Cardinality (Số lượng các giá trị duy nhất của một nhãn).</p>

  <ul class="lesson-list">
    <li>Ví dụ: Bạn gắn nhãn region (có 10 giá trị) vào Metrics → Rất tốt. Nhưng nếu bạn gắn nhãn user_id (có 1 triệu giá trị) vào Metrics của Prometheus → Boom! Prometheus của bạn sẽ nổ tung vì phải quản lý hàng triệu "time series" trong bộ nhớ.</li>
    <li><strong>Bài học:</strong> Đừng bao giờ đưa dữ liệu có Cardinality cao (như ID, Email, IP) vào Metrics. Hãy đưa chúng vào Logs hoặc Traces.</li>
  </ul>

  <h4 class="lesson-section">5. Ví dụ thực tế: Truy tìm "Sát thủ bóng đêm"</h4>

  <p class="lesson-text">Giả sử hệ thống TMĐT của bạn bị chậm lúc 12h đêm (giờ săn Sale).</p>

  <ol class="lesson-list">
    <li><strong>Metrics (Prometheus):</strong> Alert báo về điện thoại: "p99 Latency của Checkout Service tăng từ 200ms lên 5s". (Monitoring phát hiện lỗi).</li>
    <li><strong>Tracing (Jaeger):</strong> Bạn mở một vài Trace bị chậm ra và thấy: Request bị kẹt tại Discount-Service.</li>
    <li><strong>Logs (Loki):</strong> Bạn lọc log của Discount-Service theo cái TraceID vừa tìm được. Bạn thấy dòng log: Error: Connection timeout to Redis.</li>
    <li><strong>Kết luận:</strong> Redis của dịch vụ giảm giá bị quá tải do mọi người cùng vào áp mã.</li>
  </ol>

  <p class="lesson-text">→ Nếu không có Observability, bạn sẽ mất cả đêm để đoán mò. Có nó, bạn mất 2 phút để tìm ra thủ phạm.</p>

  <h3 class="lesson-summary">TỔNG KẾT BÀI 27</h3>

  <div class="lesson-summary-box">
    <p class="lesson-text">Observability là "đôi mắt" của người kỹ sư trong bóng đêm của hệ thống phân tán.</p>
    <ol class="lesson-list">
      <li>Monitoring để biết hệ thống đang "cháy".</li>
      <li>Observability để biết "ai là người châm lửa".</li>
      <li>Luôn ưu tiên OpenTelemetry để tránh bị "bắt làm con tin" bởi các nhà cung cấp dịch vụ (Vendor lock-in).</li>
      <li>Ghi nhớ: Dữ liệu không có Context (không gắn kết với nhau) chỉ là rác dữ liệu.</li>
    </ol>
    <p class="lesson-text"><strong>Nguồn trích dẫn:</strong></p>
    <ul class="lesson-list">
      <li>Observability Engineering (Charity Majors, Liz Fong-Jones) - Cuốn sách "kinh thánh" về chủ đề này.</li>
      <li>Google SRE Book - Chapter 6: Monitoring Distributed Systems.</li>
    </ul>
  </div>

  <p class="lesson-ending">
    Bài tiếp theo: Chúng ta đã có đôi mắt tinh tường để quan sát lỗi. Nhưng tại sao phải đợi lỗi xảy ra rồi mới đi tìm? Tại sao không chủ động... phá hoại hệ thống để xem nó chịu đựng giỏi đến đâu?<br>
    Chào mừng bạn đến với bài viết "điên rồ" nhất: Bài 28: Chaos Engineering - Khi lập trình viên hóa thân thành "Kẻ hủy diệt".<br>
    Câu hỏi cho bạn: Trong 3 trụ cột (Metrics, Logs, Traces), cái nào khó triển khai nhất đối với một hệ thống đã chạy lâu năm (Legacy System)? Tại sao?<br>
    Bài viết này đã đủ chi tiết và "đậm đặc" để bạn đưa lên blog cá nhân chưa? Nếu bạn cần một ví dụ cụ thể về cấu hình OpenTelemetry Collector, hãy nói cho mình biết nhé! Would you like me to deep dive into Sampling strategies (làm sao để chỉ lưu 1% Traces mà vẫn tìm thấy lỗi) hay chuyển thẳng sang Chaos Engineering?
  </p>
</div>

</body>
</html>